'''
v2
==
* TODO: command line argument for N_PROCS

v1
==
* run the configuration files generated by gen_cfg.py
* alternatively, use to run all PyRate or Pirate configuration files (with extensions .pcfg and .mcfg, respectively) in a directory
* gives feedback as to how many runs are complete and remaining

usage
-----
* $ python run_cfgs.py [-m, -b] <full directory path>
* switches
    * no switch runs .pcfg files only
    * -m .mcfg files only
    * -b for both

Matlab Runtime libraries
------------------------
* you _must_ modify the references in "DEFAULT PARAMETERS' section below to suit your environment
'''

# DEFAULT PARAMETERS ==================================================================================
# =====================================================================================================
N_PROCS = 10                                                    # max number of operating system processes want to allow # TODO: specify this at command line
mcc_exec_pth = '/home/gap/pr_testing/mcc/v2_uni/pirate'         # path to Pirate executable # TODO: since executable is in repository can link to it now
LD_LIBRARY_PATH = "/usr/local/MATLAB/MATLAB_Runtime/v85/runtime/glnxa64:/usr/local/MATLAB/MATLAB_Runtime/v85/bin/glnxa64:/usr/local/MATLAB/MATLAB_Runtime/v85/sys/os/glnxa64"

# IMPORTS =============================================================================================
# =====================================================================================================
import sys
import os
import threading
import subprocess
import time
import getopt
from os.path import join
from copy import deepcopy
from subprocess import PIPE, STDOUT
try:
    from subprocess import DEVNULL # py3k
except ImportError:
    import os
    DEVNULL = open(os.devnull, 'wb')

# COMMAND LINE ========================================================================================
# =====================================================================================================
# make default just PyRate (-b for both, -m for just Matlab)
opts, args = getopt.getopt(sys.argv[1:], 'bm')
if len(args) != 1:
    print 'must supply just 1 argument: the directory structure you wish to run'
    sys.exit(0)
if not (opts == [] or len(opts) == 1):
    print 'supply no switches or either one of -m or -b'
    sys.exit(0)
if opts == []:
    p_only = True
    m_only = False
    both = False
else:
    p_only = False
    if opts[0][0] == '-m':
        m_only = True
        both = False
    else:
        m_only = False
        both = True

# make it so it walks from this and runs anything in the walk
root_d = args[0]            # root directory. will walk from here
if not os.path.isdir(root_d):
    print 'argument not a valid directory'
    sys.exit(0)
if not ('PYRATEPATH' in os.environ):
    print 'you need to set your PYRATEPATH'
    sys.exit(0)
# TODO: check if valid directory
PYRATEPATH = os.environ['PYRATEPATH']

# configuration for running Matlab...
mcc_env = deepcopy(os.environ)
mcc_env['LD_LIBRARY_PATH'] = LD_LIBRARY_PATH

# some references used by threads
procs = []
FRST_PASS, SCND_PASS = 0, 1         # first pass = run_prepifg, second pass = run_pyrate, Pirate/Matlab

# FUNCTIONS ===========================================================================================
# =====================================================================================================
def spawner(spawn_type, prog):
    '''
    * function used by thread that spawns off subprocess module processes
    :param spawn_type:
    :param prog: don't think this parameter is used
    :return:
    '''
    global spawner_fin, procs  # modify these, so need global
    for path, dirs, files in os.walk(root_d):
        cont_fld = os.path.split(path)[1]    # containing folder
        if cont_fld == 'python' or cont_fld == 'matlab':
            continue

        for file in files:
            if (file[-5:] == '.pcfg' and (p_only or both) and spawn_type == FRST_PASS):
                # we want to run this config file. but only if there is space in the queue to do so
                while len(procs) >= N_PROCS:
                    time.sleep(1)   # TODO: wat set this to
                # since this is the only spawner, queue won't be refilled
                procs.append(subprocess.Popen(['python', join(PYRATEPATH,'pyrate','scripts', 'run_prepifg.py'), join(path,file)], stdin=PIPE, stdout=DEVNULL, stderr=STDOUT))
            if (file[-5:] == '.pcfg' and (p_only or both) and spawn_type == SCND_PASS):
                # we want to run this config file. but only if there is space in the queue to do so
                while len(procs) >= N_PROCS:
                    time.sleep(1)   # TODO: wat set this to
                # since this is the only spawner, queue won't be refilled
                procs.append(subprocess.Popen(['python', join(PYRATEPATH,'pyrate','scripts', 'run_pyrate.py'), join(path,file)], stdin=PIPE, stdout=DEVNULL, stderr=STDOUT))
            if (file[-5:] == '.mcfg' and (m_only or both) and spawn_type == SCND_PASS):
                # we want to run this config file. but only if there is space in the queue to do so
                while len(procs) >= N_PROCS:
                    time.sleep(1)   # TODO: wat set this to
                procs.append(subprocess.Popen([mcc_exec_pth, join(path,file)], env=mcc_env, stdin=PIPE, stdout=DEVNULL, stderr=STDOUT))
    spawner_fin = True

def oversee():
    '''
    * function used by thread that checks procs and removes processes from list if they have returned
    :return: Nothing
    '''
    global n_prep_left, n_runs_left, prep_fin
    while True:
        if procs != []:
            for proc in procs:
                # poll the proc... just to see what we get... and if the object stays
                if proc.poll() == None:     # process hasn't returned yet
                    time.sleep(0.1)         # may not need to sleep here
                else:
                    # inspect return code, but for now just remove from list
                    procs.remove(proc)
                    # print updates
                    if n_prep_left > 0:
                        n_prep_left -= 1
                        print str(n_prep_left)+' prep_ifgs left'
                    if n_prep_left == 0 and prep_fin == False:
                        print 'finished prepping. starting running...'
                        print str(n_runs_left)+' PyRate and Pirate runs left'
                        prep_fin = True
                        continue
                    if prep_fin:
                        n_runs_left -= 1
                        print str(n_runs_left)+' PyRate and Pirate runs left'
        elif spawner_fin:
            break

# START UP THREADS ====================================================================================
# =====================================================================================================
# firstly figure out how many directories to give indication of time taken
n_to_run = 0
for path, dirs, files in os.walk(root_d):
    for file in files:
        if file[-5:] == '.pcfg':
            n_to_run += 1
n_prep_left = n_to_run
n_runs_left = 2*n_to_run
prep_fin = False
print str(n_prep_left)+' prep_ifgs left'

if p_only or both:
    spawner_fin = False
    thr_oversee = threading.Thread(target=oversee)
    thr_spawner = threading.Thread(target=spawner, kwargs={'spawn_type': FRST_PASS, 'prog': 'run_prepifg.py'})
    thr_oversee.start()
    thr_spawner.start()
    thr_oversee.join()
    thr_spawner.join()

spawner_fin = False
thr_oversee = threading.Thread(target=oversee)
thr_spawner = threading.Thread(target=spawner, kwargs={'spawn_type': SCND_PASS, 'prog': 'run_pyrate.py'})
thr_oversee.start()
thr_spawner.start()
thr_oversee.join()
thr_spawner.join()